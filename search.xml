<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux内核与基础命令学习总结]]></title>
    <url>%2Fhhliagn.github.io%2F2019%2F02%2F02%2Ftest2%2F</url>
    <content type="text"><![CDATA[文件系统和VFS进程和线程12345678910111213141516&gt; 进程、程序与线程&gt; &gt; 程序&gt; &gt; 程序，简单的来说就是存在磁盘上的二进制文件，是可以内核所执行的代码 &gt; &gt; 进程&gt; &gt; 当一个用户启动一个程序，将会在内存中开启一块空间，这就创造了一个进程，一个进程包含一个独一无二的PID，和执行者的权限属性参数，以及程序所需代码与相关的资料。&gt; 进程是系统分配资源的基本单位。&gt; 一个进程可以衍生出其他的子进程，子进程的相关权限将会沿用父进程的相关权限。&gt; &gt; 线程&gt; &gt; 每个进程包含一个或多个线程，线程是进程内的活动单元，是负责执行代码和管理进程运行状态的抽象。&gt; 线程是独立运行和调度的基本单位。 子进程和父进程进程的层次结构（父进程与子进程）在进程执行的过程中可能会衍生出其他的进程，称之为子进程，子进程拥有一个指明其父进程PID的PPID。子进程可以继承父进程的环境变量和权限参数。 于是，linux系统中就诞生了进程的层次结构——进程树。进程树的根是第一个进程（init进程）。 过程调用的流程： fork &amp; exec一个进程生成子进程的过程是，系统首先复制(fork)一份父进程，生成一个暂存进程，这个暂存进程和父进程的区别是pid不一样，而且拥有一个ppid，这时候系统再去执行(exec)这个暂存进程，让他加载实际要运行的程序，最终成为一个子进程的存在。 服务与进程 简单的说服务(daemon)就是常驻内存的进程，通常服务会在开机时通过init.d中的一段脚本被启动。 进程通信 进程通信的几种基本方式：管道，信号量，消息队列，共享内存，快速用户控件互斥。 fork方法一个进程，包括代码、数据和分配给进程的资源。fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程， 也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。 1一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都 复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。 1234fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值： 1）在父进程中，fork返回新创建子进程的进程ID； 2）在子进程中，fork返回0； 3）如果出现错误，fork返回一个负值； 如何理解pid在父子进程中不同？ 其实就相当于链表，进程形成了链表，父进程的pid指向了子进程的pid，因为子进程没有子进程，所以pid为0。 写时复制1234567传统的fork机制是，调用fork时，内核会复制所有的内部数据结构，复制进程的页表项，然后把父进程的地址空间按页复制给子进程（非常耗时）。现代的fork机制采用了一种惰性算法的优化策略。为了避免复制时系统开销，就尽可能的减少“复制”操作，当多个进程需要读取他们自己那部分资源的副本时，并不复制多个副本出来，而是为每个进程设定一个文件指针，让它们读取同一个实际文件。显然这样的方式会在写入时产生冲突（类似并发），于是当某个进程想要修改自己的那个副本时，再去复制该资源，（只有写入时才复制，所以叫写时复制）这样就减少了复制的频率。 父子进程，僵尸进程，孤儿进程，守护进程父进程通过fork产生子进程。 孤儿进程：当子进程未结束时父进程异常退出，原本需要由父进程进行处理的子进程变成了孤儿进程，init系统进程会把这些进程领养，避免他们成为孤儿。 僵尸进程：当子进程结束时，会在内存中保留一部分数据结构等待父亲进程显式结束，如果父进程没有执行结束操作，则会导致子进程的剩余结构无法被释放，占用空间造成严重后果。 守护进程：守护进程用于监控其他进程，当发现大量僵尸进程时，会找到他们的父节点并杀死，同时让init线程认养他们以便释放这些空间。 僵尸进程是有害的，孤儿进程由于内核进程的认养不会造成危害。 进程组和会话 会话和进程组进程组每个进程都属于某个进程组，进程组就是由一个或者多个为了实现作业控制而相互关联的进程组成的。 一个进程组的id是进程组首进程的pid（如果一个进程组只有一个进程，那进程组和进程其实没啥区别）。 进程组的意义在于，信号可以发送给进程组中的所有进程。这样可以实现对多个进程的同时操作。会话会话是一个或者多个进程组的集合。 一般来说，会话(session)和shell没有什么本质上的区别。我们通常使用用户登录一个终端进行一系列操作这样的例子来描述一次会话。 举例 $cat ship-inventory.txt | grep booty|sort上面就是在某次会话中的一个shell命令，它会产生一个由3个进程组成的进程组。 守护进程守护进程（服务）守护进程(daemon)运行在后台，不与任何控制终端相关联。通常在系统启动时通过init脚本被调用而开始运行。 在linux系统中，守护进程和服务没有什么区别。对于一个守护进程，有两个基本的要求：其一：必须作为init进程的子进程运行，其二：不与任何控制终端交互。 硬连接和软连接硬链接指的是不同的文件名指向同一个inode节点，比如某个目录下的a和另一个目录下的b，建立一个软连接让a指向b，则a和b共享同一个inode。 软连接是指一个文件的inode节点不存数据，而是存储着另一个文件的绝对路径，访问文件内容时实际上是去访问对应路径下的文件inode，这样的话文件发生改动或者移动都会导致软连接失效。 线程线程基础概念线程是进程内的执行单元（比进程更低一层的概念），具体包括 虚拟处理器，堆栈，程序状态等。可以认为 线程是操作系统调度的最小执行单元。 现代操作系统对用户空间做两个基础抽象:虚拟内存和虚拟处理器。这使得进程内部“感觉”自己独占机器资源。 虚拟内存系统会为每个进程分配独立的内存空间，这会让进程以为自己独享全部的RAM。 但是同一个进程内的所有线程共享该进程的内存空间。虚拟处理器这是一个针对线程的概念，它让每个线程都“感觉”自己独享CPU。实际上对于进程也是一样的。 线程模型线程模型线程的概念同时存在于内核和用户空间中。下面介绍三种线程模型。 1234567内核级线程模型每个内核线程直接转换成用户空间的线程。即内核线程：用户空间线程=1：1用户级线程模型这种模型下，一个保护了n个线程的用户进程只会映射到一个内核进程。即n:1。可以减少上下文切换的成本，但在linux下没什么意义，因为linux下进程间的上下文切换本身就没什么消耗，所以很少使用。混合式线程模型上述两种模型的混合，即n:m型。很难实现。 内核线程实现系统线程实现：PThreads原始的linux系统调用中，没有像C++11或者是Java那样完整的线程库。 整体看来pthread的api比较冗余和复杂，但是基本操作也主要是 创建、退出等。 1.创建线程 12345int pthread_create(若线程创建成功，则返回0。若线程创建失败，则返回出错编号) 注意:线程创建者和新建线程之间没有fork()调用那样的父子关系，它们是对等关系。调用pthread_create()创建线程后，线程创建者和新建线程哪个先运行是不确定的，特别是在多处理机器上。 2.终止线程 123void pthread_exit(void *value_ptr); 线程调用pthread_exit()结束自己，参数value_ptr作为线程的返回值被调用pthread_join的线程使用。由于一个进程中的多个线程是共享数据段的，因此通常在线程退出之后，退出线程所占用的资源并不会随着线程的终止而得到释放，但是可以用pthread_join()函数来同步并释放资源 3.取消线程 123int pthread_cancel(pthread_t thread); 注意：若是在整个程序退出时，要终止各个线程，应该在成功发送 CANCEL指令后，使用 pthread_join函数，等待指定的线程已经完全退出以后，再继续执行；否则，很容易产生 “段错误”。 4.连接线程（阻塞） 12345 int pthread_join(pthread_t thread, void **value_ptr); 等待线程thread结束，并设置*value_ptr为thread的返回值。pthread_join阻塞调用者，一直到线程thread结束为止。当函数返回时，被等待线程的资源被收回。如果进程已经结束，那么该函数会立即返回。并且thread指定的线程必须是joinable的。需要留意的一点是linux机制下，线程存在一个被称为joinable的状态。下面简要了解一下： Join和Detach这块的概念，非常类似于之前父子进程那部分，等待子进程退出的内容（一系列的wait函数）。 linux机制下，线程存在两种不同的状态：joinable和unjoinable。 12345如果一个线程被标记为joinable时，即便它的线程函数执行完了，或者使用了pthread_exit()结束了该线程，它所占用的堆栈资源和进程描述符都不会被释放（类似僵尸进程），这种情况应该由线程的创建者调用pthread_join()来等待线程的结束并回收其资源（类似wait系函数）。默认情况下创建的线程都是这种状态。如果一个线程被标记成unjoinable，称它被分离(detach)了，这时候如果该线程结束，所有它的资源都会被自动回收。省去了给它擦屁股的麻烦。因为创建的线程默认都是joinable的，所以要么在父线程调用pthread_detach(thread_id)将其分离，要么在线程内部，调用pthread_detach(pthread_self())来把自己标记成分离的。 文件系统12345678910文件描述符在linux内核中，文件是用一个整数来表示的，称为 文件描述符，通俗的来说，你可以理解它是文件的id（唯一标识符）普通文件普通文件就是字节流组织的数据。文件并不是通过和文件名关联来实现的，而是通过关联索引节点来实现的，文件节点拥有文件系统为普通文件分配的唯一整数值(ino)，并且存放着一些文件的相关元数据。目录与链接正常情况下文件是通过文件名来打开的。目录是可读名称到索引编号之间的映射，名称和索引节点之间的配对称为链接。可以把目录看做普通文件，只是它包含着文件名称到索引节点的映射（链接） 文件系统是基于底层存储建立的一个树形文件结构。比较经典的是Linux的文件系统，首先在硬盘的超级块中安装文件系统，磁盘引导时会加载文件系统的信息。 linux使用inode来标识任意一个文件。inode存储除了文件名以外的文件信息，包括创建时间，权限，以及一个指向磁盘存储位置的指针，那里才是真正存放数据的地方。 一个目录也是一个inode节点。 详细阐述一次文件访问的过程： 1234567首先用户ls查看目录。由于一个目录也是一个文件，所以相当于是看目录文件下有哪些东西。实际上目录文件是一个特殊的inode节点，它不需要存储实际数据，而只是维护一个文件名到inode的映射表。于是我们ls到另一个目录。同理他也是一个inode。我们在这个inode下执行vi操作打开某个文件，于是linux通过inode中的映射表找到了我们请求访问的文件名对应的inode。然后寻道到对应的磁盘位置，读取内容到缓冲区，通过系统调用把内容读到内存中，最后进行访问。 testccc test2bbb test3aaa]]></content>
      <categories>
        <category>后端</category>
        <category>技术总结</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2Fhhliagn.github.io%2F2019%2F02%2F02%2Ftest%2F</url>
    <content type="text"><![CDATA[we start here.]]></content>
  </entry>
</search>
