<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F07%2FGit%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E5%88%B0GitHub%2F</url>
    <content type="text"><![CDATA[title:Git部署项目到GitHubdate:2019-03-07 21:43:05tags:[Git,GitHub] categories:[后端,项目管理]Git部署项目到GitHub创建远程仓库:github: New Repostitory 以下操作在项目根目录下进行 创建本地仓库:1.项目根目录下git bash: git init 生成新仓库 (项目根目录和.git同级) 或者TortoiseGit客户端在这里创建新的版本库 2.IDE中”VCS”-“VCS Operations Popup”-“Create Git Repository” 选择项目根目录即可 添加忽略列表:创建.gitignore文件, 放在项目根目录下 或者TortoiseGit客户端-添加到忽略文件 添加远程库:git remote add 远端名称 远程库ssh地址 git remote add RepositoryName git@github.com:username/RepositoryName.git 同步代码到远程库:git push -u 远端名称 分支名称 git push -u RepositoryName master 或者TortoiseGit客户端-推送 Github仓库克隆新建一个空目录 git clone git@github.com:username/RepositoryName.git 或者TortoiseGit客户端-Git克隆 Github拉取代码git fetch：相当于是从远程获取最新版本到本地，不会自动merge（合并代码） git pull：相当于是从远程拉取最新版本并merge到本地 或者TortoiseGit客户端-拉取 删除远程库git remote rm 远端名称 git remote rm RepositoryName]]></content>
  </entry>
  <entry>
    <title><![CDATA[java基础2_基本数据类型和常量池]]></title>
    <url>%2F2019%2F02%2F03%2Fjava%E5%9F%BA%E7%A1%802-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%B8%B8%E9%87%8F%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[转载自:http://h2pl.github.io 作者:h2pl 基本数据类型大小int 32位 4字节 double 64位 8字节 short 16位 long 64位 8字节 -2的63次方~2的63次方-1 char 16位 2字节 byte 8位 1字节 -128 ~ 127 boolean 1位 自动装箱和自动拆箱12自动拆箱和装箱的意思就是，计算数值时，integer会自动转为int进行计算。而当int传入类型为integer的引用时，int数值又会被包装为integer。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static void main(String[] args) &#123; //基本数据类型的常量池在-128 ~127之间 //在这个范围中的基本数据类的包装类可以自动拆箱，比较时直接比较数值大小。 Integer i1=128; Integer i2=128; Integer i3=-128; Integer i4=-128; //int的自动拆箱和装箱只在-128到127范围中进行，超过该范围的两个integer的 == 判断是会返回false的 System.out.println(i1==i2); System.out.println(i3==i4); Long l1=128L; Long l2=128L; Long l3=-128L; Long l4=-128L; System.out.println(l1==l2); System.out.println(l3==l4); //Byte总是相等,因为范围就是-128 ~ 127 Byte b1=127; Byte b2=127; Byte b3=-128; Byte b4=-128; System.out.println(b1==b2); System.out.println(b3==b4); //char没有负值,发现也是在0 ~127之间自动拆箱 Character c1=127; Character c2=127; Character c3=128; Character c4=128; System.out.println(c1==c2); System.out.println(c3==c4); Integer i=10; Byte b=10; //Byte 和 Integer 两个对象无法直接比较,报错 //System.out.println(i==b); System.out.println("i==b "+i.equals(b)); //equals先比较是否同一个类,不同直接返回false int ii=128; short ss=128; long ll=128L; char cc=128; byte bb=127; int ib=127; System.out.println("ii==ss "+(ii==ss)); System.out.println("ii==ll "+(ii==ll)); System.out.println("ii==cc "+(ii==cc)); System.out.println("bb==ib "+(bb==ib)); //这时候都是true，因为基本数据类型直接比较值，值一样就可以。 &#125; 基本数据类型的存储方式12345678910111213141516171819202122上面自动拆箱和装箱的原理其实与常量池有关。3.1存在栈中：public void(int a)&#123;int i = 1;int j = 1;&#125;方法中的i 存在虚拟机栈的局部变量表里，i是一个引用，j也是一个引用，它们都指向局部变量表里的整型值 1.int a是传值引用，所以a也会存在局部变量表。3.2存在堆里：class A&#123;int i = 1;A a = new A();&#125;i是类的成员变量。类实例化的对象存在堆中，所以成员变量也存在堆中，引用a存的是对象的地址，引用i存的是值，这个值1也会存在堆中。可以理解为引用i指向了这个值1。也可以理解为i就是1.3.3包装类对象怎么存其实我们说的常量池也可以叫对象池。比如String a= new String(&quot;a&quot;).intern()时会先在常量池找是否有“a&quot;对象如果有的话直接返回“a&quot;对象在常量池的地址，即让引用a指向常量”a&quot;对象的内存地址。public native String intern(); Integer也是同理。 当我们使用包装类的时候,其实是新建了一个对象: 12Integer a=12;Integer a=new Integer(12); 下图是Integer类型在常量池中查找同值对象的方法。 1234567891011121314151617181920212223242526272829303132333435363738public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125;private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125;&#125; 所以基本数据类型的包装类型可以在常量池查找对应值的对象，找不到就会自动在常量池创建该值的对象。 而String类型可以通过intern来完成这个操作。 常量池常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。 有关常量池的概念: constant pool 是指编译期就被确定的各种字面量和符号引用，存在于方法区的Runtime Constant Pool java的8种基本类型:java中基本类型的包装类的大部分都实现了常量池技术,即除了两种浮点数类型外的其余六种：Character,Byte,Short,Integer,Long,Boolean.但是需要注意，除了Boolean之外的五种封装类只有在[-128,127]范围内才在常量池内有对象。 String类型:1.直接由双引号声明的String对象是字符串常量，编译期间直接放到常量池,下次使用相同的字符串常量时直接从常量池中取 123String s1 = "11";String s2 = "11";System.out.println(s1 == s2); 1234567891011121314151617181920212223//常量字符串和变量拼接时,会调用StringBuilder.append()在堆上创建新的对象。 String s11="11";String s12=s11+"12";String s13="1112";System.out.println(s12==s13); //false//纯变量拼接,会调用StringBuilder.append()在堆上创建新的对象。 String s14="14";String s15="15";String s16="1415";System.out.println(s14+s15==s16); //false//纯常量字符串的“+”操作,编译阶段直接会合成为一个字符串。于是会去常量池中查找是否存在”JAVA”,从而进行创建或引用。String s17="17"+"18";String s18="1718";System.out.println(s17==s18);//对于final字段，编译期直接进行了常量替换（而对于非final字段则是在运行期进行赋值处理的）。final String s19="19";final String s20="20";String s21=s19+s20;String s22="1920";System.out.println(s21==s22); 2.new String创建的String对象都存放在堆中,可以通过String.intern()方法放入常量池 12345678910111213141516171819String s3 = "118";String s4 = new String("118");System.out.println(s3==s4);System.out.println(s3==s4.intern());String s5 = new String("118");String s6 = "118";System.out.println(s5.intern()==s6); //trueString s7 = new String("118");String intern1 = s7.intern();String s8 = "118";System.out.println(intern1==s8); //trueString s9 = new String("118");String intern2 = s9.intern();String s10 = new String("118");String intern3 = s10.intern();System.out.println(intern2==intern3); //true JDK1.6查找到常量池存在相同值的对象时会直接返回该对象的地址。 JDK 1.7后，intern方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与之前没有区别，区别在于，如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用。 那么其他字符串在常量池找值时就会返回另一个堆中对象的地址 String的equal和==比较 123String s1="test";String s2=new String("test");System.out.println(s1==s2); //false java中直接使用==操作符，比较的是两个字符串的引用地址，equals比较的是内容。s1的引用地址在方法区里，s2是一个对象，其地址在堆里，所以不相等 String s = new String(“test”); 创建了几个对象？ 分析：考虑到整个类的加载过程，“test”本身在编译期就被放到了常量池里，在执行new String()时把常量池里的“test”复制到堆中，并把这个对象的引用赋值给s,因此有两个：一个是new String(),另一个是匿名的“test”]]></content>
      <categories>
        <category>后端</category>
        <category>java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java基础1_面向对象的三大特性]]></title>
    <url>%2F2019%2F02%2F03%2Fjava%E5%9F%BA%E7%A1%801-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[转载自:http://h2pl.github.io 作者:h2pl 继承Java中的继承只能单继承，但是可以通过内部类继承其他类来实现多继承。 123456789101112131415161718192021222324252627282930public class Son extends Father&#123; public void go () &#123; System.out.println("son go"); &#125; public void eat () &#123; System.out.println("son eat"); &#125; public void sleep() &#123; System.out.println("zzzzzz"); &#125; public void cook() &#123; //匿名内部类实现的多继承 new Mother().cook(); //内部类继承第二个父类来实现多继承 Mom mom = new Mom(); mom.cook(); &#125; /*private class Mom extends 抽象类&#123; //内部类继承抽象类 @Override public void cook() &#123; System.out.println("mom cook"); &#125; &#125;*/ private class Mom extends Mother implements 接口,接口1&#123; //内部类继承非抽象类并实现多个接口 @Override public void cook() &#123; System.out.println("mom cook"); &#125; &#125;&#125; 封装封装主要是因为Java有访问权限的控制。public &gt; protected &gt; package = default &gt; private。封装可以保护类中的信息，只提供想要被外界访问的信息。 类的访问范围 1234A、public 包内、包外，所有类中可见B、protected 包内所有类可见，包外有继承关系的子类可见(子类对象可调用)C、(default) 表示默认，不仅本类访问，而且是同包可。D、private 仅在同一类中可见 多态多态一般可以分为两种，一个是重写override，一个是重载overload。 1234567重写是由于继承关系中的子类有一个和父类同名同参数的方法，会覆盖掉父类的方法。重载是因为一个同名方法可以传入多个参数组合。注意，同名方法如果参数相同，即使返回值不同也是不能同时存在的，编译会出错。从jvm实现的角度来看，重写又叫运行时多态，编译时看不出子类调用的是哪个方法，但是运行时操作数栈会先根据子类的引用去子类的类信息中查找方法，找不到的话再到父类的类信息中查找方法。而重载则是编译时多态，因为编译期就可以确定传入的参数组合，决定调用的具体方法是哪一个了。 向上转型和向下转型1234567891011121314151617181920212223242526272829303132333435363738394041424344public static void main(String[] args) &#123; //转型是指左侧引用的改变 //向上转型,父类引用指向子类实例 Father father=new Son(); father.drive(); father.smoke(); //运行时是指向实例中的方法,没有才去父类找 //不能使用子类特有方法,编译报错 //father.play(); //向下转型,子类引用指向父类实例 Son son=(Son) father; son.drive(); son.play(); son.smoke(); //运行时是指向实例中的方法,没有才去父类找 //向下转型必须先经过向上转型 //向下转型的两种情况: Father f1 = new Father(); //父类指向父类本身 //不安全的向下转型,会出现ClassCastException错误 Son s1 = (Son) f1; s1.drive(); s1.play(); s1.smoke(); Father f2=new Son(); //父类指向子类实例,向上转型 //安全的向下转型 Son s2=(Son) f2; s2.drive(); s2.play(); s2.smoke(); //转型的用法:方法参数中类型聚合,具体操作再分解 //传入参数时集合经历向上转型 add(new ArrayList()); &#125; public static void add(List list)&#123; System.out.println(list); //具体操作时集合经历向下转型 ArrayList arrayList= (ArrayList) list; &#125;&#125; 总结： 向上转型和向下转型都是针对引用的转型，是编译期进行的转型，根据引用类型来判断使用哪个方法。并且在传入方法时会自动进行转型（有需要的话）。运行期将引用指向实例，如果是不安全的转型则会报错，若安全则继续执行方法。 动态分派和静态分派机制是Java多态实现的原理。 静态分派12345678910111213141516171819202122public static void main(String[] args) &#123; //编译期的静态分派 //静态分派实际上是根据引用类型确定调用的方法,常用于方法重载 Father father=new Son(); test2 a = new test2(); //编译期确定引用类型为Father,调用第一个方法 a.print(father); //向下转型后,引用类型为Son,调用第二个方法 //所以，编译期只确定了引用，运行期再进行实例化。 a.print((Son) father); //如果没有Son类型的方法,会自动向上转型调用第三个方法 a.smoke((Son) father); &#125; public void print(Father father)&#123; System.out.println("this is father"); father.drive(); &#125; public void print(Son son)&#123; System.out.println("this is son"); &#125; public void smoke(Father father)&#123; father.smoke(); &#125; 动态分派123456public static void main(String[] args) &#123; //运行期的动态分派 Father father=new Son(); father.drive(); //输出: son drive //对于方法重写，Java采用的是动态分派机制，也就是说在运行的时候才确定调用哪个方法。 //由于father的实际类型是Son，因此调用的就是Son的drive方法。 &#125; 方法重载优先级匹配12345678910111213public static void main(String[] args) &#123; 方法重载优先级匹配 a = new 方法重载优先级匹配(); //普通的重载一般就是同名方法不同参数。 //这里我们来讨论当同名方法只有一个参数时的情况。 //此时会调用char参数的方法。 //当没有char参数的方法。会调用int类型的方法，如果没有int就调用long //即存在一个调用顺序char -&gt; int -&gt; long -&gt;double -&gt; ..。 //当没有基本类型对应的方法时，先自动装箱，调用包装类方法。 //如果没有包装类方法，则调用包装类实现的接口的方法。 //最后再调用持有多个参数的char...方法。 a.eat('a'); a.eat('a','c','b');&#125;]]></content>
      <categories>
        <category>后端</category>
        <category>java基础</category>
      </categories>
  </entry>
</search>
